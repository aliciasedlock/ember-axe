<script>
  /**
   * Setup all our functions as an extension to the global axe object. This
   * ensures their availability while also avoiding a continual pollution of the
   * global namespace.
   */
  axe.ember = {
    /**
     * The current number of times the axe audit has run for a given module.
     * @private
     * @type {Number}
     */
    _auditCount: 0,

    /**
     * A simple wrapper around inserting a debugger.
     * @private
     * @return {Void}
     */
    _debugger: function() {
      debugger;
    },

    /**
     * Processes the results of calling axe.a11yCheck. If there are any
     * violations, it throws an error and then logs them individually.
     * @param {Object} results
     * @return {Void}
     */
    a11yCheckCallback: function(results) {
      var violations = results.violations;
      var length = violations.length;
      var violation;
      var message;

      if (length) {
        // Log a message stating how many violations were found, on which audit
        // run, and in which module
        message = length === 1 ? '1 violation' : length + ' violations';
        message += ' found on audit run #' + axe.ember._auditCount +
          ' for module "' + QUnit.config.current.module.name + '"';

        Ember.Logger.error(message);
      }

      for (var i = 0; i < length; i++) {
        violation = violations[i];

        // Log each individual violation in an easy-to-read format
        message = 'Violation #' + (i + 1) + ': ';
        message += violation.impact.toUpperCase() + ': ' + violation.help + '. ';
        message += 'See the rule definition for this violation at: https://github.com/dequelabs/axe-core/blob/master/lib/rules/' + violation.id + '.json. ';
        message += 'Here is the raw violation information:';

        Ember.Logger.error(message, violation);
      }

      // Throw an error if we found violations
      Ember.assert('The application should have no accessibility violations.', !length);
    },

    /**
     * Used as a callback for afterRender. Simply runs axe.a11yCheck and passes
     * the results to a11yCheckCallback.
     * @return {Void}
     */
    afterRender: function() {
      axe.ember._auditCount++;
      axe.a11yCheck('#ember-testing-container', axe.ember.testOptions, axe.ember.a11yCheckCallback);

      // Check if we're on an audit that we plan to break on
      if (axe.ember._auditCount === axe.ember.breakOnAudit) {
        axe.ember._debugger();
      }
    },

    /**
     * Specifies an audit run number to break on (adds a debugger).
     * @type {Number}
     */
    breakOnAudit: undefined,

    /**
     * Used as a callback at the beginning of each testing module. It checks
     * if the test is an acceptance test (based on standard Ember-CLI naming
     * conventions), and adjust the testing display accordingly.
     * @param {Object} details
     * @return {Void}
     */
    moduleStart: function(details) {
      // Make sure we reset any audit breaks from the previous module
      axe.ember.breakOnAudit = undefined;

      if (~details.name.indexOf('Acceptance')) {
        axe.ember.turnAxeOn();
      } else {
        axe.ember.turnAxeOff();
      }
    },

    /**
     * Used as a callback at the end of testing. It ensures the testing display
     * has been reset to it's original appearance.
     * @return {Void}
     */
    qunitDone: function() {
      axe.ember.turnAxeOff();
    },

    /**
     * Enables the axe-core tests to run on afterRender and modifies the visual
     * layout of the testing.
     * @return {Void}
     */
    turnAxeOn: function() {
      Ember.run.backburner.options.render = { after: axe.ember.afterRender };
      document.body.classList.add('axe-enabled');
    },

    /**
     * Disables the axe-core tests to run on afterRender and restores the
     * original visual layout of the testing.
     * @return {Void}
     */
    turnAxeOff: function() {
      Ember.run.backburner.options.render = { after: undefined };
      document.body.classList.remove('axe-enabled');
    },

    /**
     * An object of options to pass into axe.a11yCheck.
     * @type {Object}
     */
    testOptions: undefined
  };

  // Register the functions to their appropriate places for testing
  QUnit.moduleStart(axe.ember.moduleStart);
  QUnit.done(axe.ember.qunitDone);
</script>
